<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>AMD GPU Ring Buffer - Wang Yang&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Wang Yang&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Wang Yang&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本文所讨论的均为AMD公司的显卡产品 显卡：AMD Radeon RX 5500 - 8GB 显存 Linux：Linux-5.4.y  (fc944ddc0b4a)  背景现代的驱动模型中，一般有2种方式来操作硬件：  PUSH：CPU通过读写寄存器的方式来控制GPU硬件。 PULL：CPU将命令写到一块buffer中，并通知硬件，由硬件来解析命令并执行。  2种模式各有优劣，使用PUSH的方"><meta property="og:type" content="blog"><meta property="og:title" content="AMD GPU Ring Buffer"><meta property="og:url" content="https://xxlnx.github.io/2020/10/25/amdgpu/AMD_GPU_Ring/"><meta property="og:site_name" content="Wang Yang&#039;s Blog"><meta property="og:description" content="本文所讨论的均为AMD公司的显卡产品 显卡：AMD Radeon RX 5500 - 8GB 显存 Linux：Linux-5.4.y  (fc944ddc0b4a)  背景现代的驱动模型中，一般有2种方式来操作硬件：  PUSH：CPU通过读写寄存器的方式来控制GPU硬件。 PULL：CPU将命令写到一块buffer中，并通知硬件，由硬件来解析命令并执行。  2种模式各有优劣，使用PUSH的方"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://xxlnx.github.io/2020/10/25/amdgpu/AMD_GPU_Ring/amdgpu_ring_buffer.png"><meta property="og:image" content="https://xxlnx.github.io/2020/10/25/amdgpu/AMD_GPU_Ring/pm4-packet0.png"><meta property="og:image" content="https://xxlnx.github.io/2020/10/25/amdgpu/AMD_GPU_Ring/pm4-packet2.png"><meta property="og:image" content="https://xxlnx.github.io/2020/10/25/amdgpu/AMD_GPU_Ring/pm4-packet3.png"><meta property="og:image" content="https://xxlnx.github.io/2020/10/25/amdgpu/AMD_GPU_Ring/pm4-indirect-buffer.png"><meta property="article:published_time" content="2020-10-25T10:12:31.000Z"><meta property="article:modified_time" content="2020-10-25T10:12:31.000Z"><meta property="article:author" content="Wang Yang"><meta property="article:tag" content="kernel"><meta property="article:tag" content="amdgpu"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2020/10/25/amdgpu/AMD_GPU_Ring/amdgpu_ring_buffer.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xxlnx.github.io/2020/10/25/amdgpu/AMD_GPU_Ring/"},"headline":"AMD GPU Ring Buffer","image":["https://xxlnx.github.io/2020/10/25/amdgpu/AMD_GPU_Ring/amdgpu_ring_buffer.png","https://xxlnx.github.io/2020/10/25/amdgpu/AMD_GPU_Ring/pm4-packet0.png","https://xxlnx.github.io/2020/10/25/amdgpu/AMD_GPU_Ring/pm4-packet2.png","https://xxlnx.github.io/2020/10/25/amdgpu/AMD_GPU_Ring/pm4-packet3.png","https://xxlnx.github.io/2020/10/25/amdgpu/AMD_GPU_Ring/pm4-indirect-buffer.png"],"datePublished":"2020-10-25T10:12:31.000Z","dateModified":"2020-10-25T10:12:31.000Z","author":{"@type":"Person","name":"Wang Yang"},"description":"本文所讨论的均为AMD公司的显卡产品 显卡：AMD Radeon RX 5500 - 8GB 显存 Linux：Linux-5.4.y  (fc944ddc0b4a)  背景现代的驱动模型中，一般有2种方式来操作硬件：  PUSH：CPU通过读写寄存器的方式来控制GPU硬件。 PULL：CPU将命令写到一块buffer中，并通知硬件，由硬件来解析命令并执行。  2种模式各有优劣，使用PUSH的方"}</script><link rel="canonical" href="https://xxlnx.github.io/2020/10/25/amdgpu/AMD_GPU_Ring/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/xcode.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.png" alt="Wang Yang&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/xxlnx"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-10-25T10:12:31.000Z" title="10/25/2020, 6:12:31 PM">2020-10-25</time>发表</span><span class="level-item"><time dateTime="2020-10-25T10:12:31.000Z" title="10/25/2020, 6:12:31 PM">2020-10-25</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/amdgpu/">amdgpu</a></span><span class="level-item">25 分钟读完 (大约3746个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">AMD GPU Ring Buffer</h1><div class="content"><blockquote>
<p>本文所讨论的均为AMD公司的显卡产品</p>
<p>显卡：AMD Radeon RX 5500 - 8GB 显存</p>
<p>Linux：Linux-5.4.y  (<a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=linux-5.4.y&id=a65e788634437d7cdaf402930acdf210000f3957">fc944ddc0b4a</a>)</p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>现代的驱动模型中，一般有2种方式来操作硬件：</p>
<ul>
<li><strong>PUSH</strong>：CPU通过读写寄存器的方式来控制GPU硬件。</li>
<li><strong>PULL</strong>：CPU将命令写到一块buffer中，并通知硬件，由硬件来解析命令并执行。</li>
</ul>
<p>2种模式各有优劣，使用<strong>PUSH</strong>的方式一般都为同步操作，需要占用CPU时间，并且在GPU领域有大量的寄存器是不方便用户直接读写的，所以GPU大多数采用的是<strong>PULL</strong>方式。因此本文主要介绍AMD KMD Ring Buffer的原理和实现。</p>
<h1 id="AMD-GPU-Ring-Buffer"><a href="#AMD-GPU-Ring-Buffer" class="headerlink" title="AMD GPU Ring Buffer"></a>AMD GPU Ring Buffer</h1><p><img src="/2020/10/25/amdgpu/AMD_GPU_Ring/amdgpu_ring_buffer.png" alt="AMD GPU Ring Buffer"></p>
<span id="more"></span>

<p>在软件领域，生产消费模型是一个典型的软件模型，一端负责生产数据，另一端负责消费数据，两端通过某种规则建立一种数据通道来达到通信的目的，同样的在GPU领域，CPU作为生产者，产生命令，GPU作为消费者，解析并执行命令，因此CPU和GPU就完成了通信。</p>
<p>在KMD驱动中，CPU通过一个<code>Ring Buffer</code>的软件模型和硬件进行通信，<code>Ring Buffer</code>就是一个环形缓冲区，内部有<code>wptr</code>和<code>rptr</code>来维护<code>Ring</code>的状态，在CPU写入数据的时候CPU会更新<code>wptr</code>，当GPU消费数据后会更新<code>rptr</code>， 因此GPU的状态可以大致分为2种：</p>
<ul>
<li>rptr == wptr：Ring Buffer为空，GPU没有命令需要处理</li>
<li>rptr != wptr： Ring Buffer有数据，GPU解析并执行命令</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Field</th>
<th align="center">Description</th>
<th align="center">Note</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Buffer Base</td>
<td align="center">唤醒缓冲区的地址</td>
<td align="center">CPU/GPU都可以访问这个唤醒缓冲区</td>
</tr>
<tr>
<td align="center">Buffer Size</td>
<td align="center">唤醒缓冲区的大小</td>
<td align="center">约定缓冲区的大小</td>
</tr>
<tr>
<td align="center">Writer Pointer</td>
<td align="center">写指针</td>
<td align="center">CPU发送命令的时候更新wptr</td>
</tr>
<tr>
<td align="center">Read Pointer</td>
<td align="center">读指针</td>
<td align="center">GPU处理完命令后更新rptr</td>
</tr>
</tbody></table>
<p>在 AMD GPU内部，硬件会根据Engine的类型提供不同数量的Queue（Ring）和软件进行交互，相同Engine下的不同Queue会根据配置具有不同的硬件能力：</p>
<table>
<thead>
<tr>
<th>Engine</th>
<th>Ring Count</th>
<th>Note</th>
</tr>
</thead>
<tbody><tr>
<td>GFX</td>
<td>1 - 2~</td>
<td>3D Graphcis： 3D and HP3D</td>
</tr>
<tr>
<td>Compute</td>
<td>32~</td>
<td>数学/矩阵计算</td>
</tr>
<tr>
<td>SDMA</td>
<td>(1 - 7) * 10~</td>
<td>System DMA 数据拷贝/填充/搬运…</td>
</tr>
<tr>
<td>UVD</td>
<td>1~</td>
<td>Unified Video Decode</td>
</tr>
<tr>
<td>VCE</td>
<td>1~</td>
<td>Video Encode Engine</td>
</tr>
</tbody></table>
<h1 id="AMD-GPU-Ring-命令类型"><a href="#AMD-GPU-Ring-命令类型" class="headerlink" title="AMD GPU Ring 命令类型"></a>AMD GPU Ring 命令类型</h1><p>不同Engine定义了不同类型的命令，其中最主要的GFX/Compute Engined定义了2种命令类型：</p>
<ul>
<li>PM4：AMD GPU内部主要的命令类型。 <a target="_blank" rel="noopener" href="https://developer.amd.com/wordpress/media/2013/10/si_programming_guide_v2.pdf">PM4</a></li>
<li>AQL (Architected Queuing Language)： HSA 组织定义的命令类型 (Compute Only)。 <a target="_blank" rel="noopener" href="http://www.hsafoundation.com/html/Content/Runtime/Topics/Runtime_title_page.htm">HSA-AQL</a></li>
</ul>
<h2 id="PM4-Packet-0"><a href="#PM4-Packet-0" class="headerlink" title="PM4: Packet 0"></a>PM4: Packet 0</h2><blockquote>
<p>Type-0 Packets are discouraged, but can be used if absolutely required. Type-3 packets should be used instead. Write N DWords in the information body to the N consecutive registers, or to the register, pointed to by the BASE_INDEX field of the packet header. Does check for context roll. This packet supports a register memory map up to 64K DWords (256K Bytes). </p>
</blockquote>
<p><img src="/2020/10/25/amdgpu/AMD_GPU_Ring/pm4-packet0.png" alt="PM4 PKT-0"></p>
<h2 id="PM4-Packet-1"><a href="#PM4-Packet-1" class="headerlink" title="PM4: Packet 1"></a>PM4: Packet 1</h2><blockquote>
<p>Not Support.</p>
</blockquote>
<h2 id="PM4-Packet-2"><a href="#PM4-Packet-2" class="headerlink" title="PM4: Packet 2"></a>PM4: Packet 2</h2><blockquote>
<p>This is a filler packet. It has only the header, and its content is not important except for bits 30 and 31. It is used to fill up the trailing space left when the allocated buffer for a packet, or packets, is not fully filled. This allows the CP to skip the trailing space and to fetch the next packet.</p>
</blockquote>
<p><img src="/2020/10/25/amdgpu/AMD_GPU_Ring/pm4-packet2.png" alt="PM4 PKT-2"></p>
<h2 id="PM4-Packet-3"><a href="#PM4-Packet-3" class="headerlink" title="PM4: Packet 3"></a>PM4: Packet 3</h2><blockquote>
<p>Type-3 packets have a common format for their headers. However, the size of their information body may vary depending on the value of field IT_OPCODE. The size of the information body is indicated by field COUNT. If the size of the information is N DWords, the value of COUNT is N-1. In the following packet definitions, we will describe the field IT_BODY for each packet with respect to a given IT_OPCODE, and omit the header. . </p>
</blockquote>
<p><img src="/2020/10/25/amdgpu/AMD_GPU_Ring/pm4-packet3.png" alt="PM4 PKT-3"></p>
<p>Packet3 是现在GPU支持最多的命令类型</p>
<ul>
<li>HEADER:<ul>
<li>TYPE: 3</li>
<li>COUNT: IT_BODY 长度 - 1</li>
<li>IT_OPCODE: OP 操作码，用于表示具体的命令类型</li>
<li>SHADER_TYPE: GFX 或者 Compute</li>
</ul>
</li>
<li>IT_BOBDY：根据<code>IT_OPCODE</code>不同，填写不同的命令内容</li>
</ul>
<h3 id="PKT3-IT-OPCODE-列表"><a href="#PKT3-IT-OPCODE-列表" class="headerlink" title="PKT3 IT_OPCODE 列表"></a>PKT3 IT_OPCODE 列表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">drivers/gpu/drm/amd/amdgpu/soc15d.h</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACKET3(op, n)	((PACKET_TYPE3 &lt;&lt; 30) |				\</span></span><br><span class="line">			 (((op) &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>) |				\</span><br><span class="line">			 ((n) &amp; <span class="number">0x3FFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACKET3_COMPUTE(op, n) (PACKET3(op, n) | 1 &lt;&lt; 1)</span></span><br><span class="line">....</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Packet 3 types */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	PACKET3_NOP					0x10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	PACKET3_SET_BASE				0x11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		PACKET3_BASE_INDEX(x)                  ((x) &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>			CE_PARTITION_BASE		3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	PACKET3_CLEAR_STATE				0x12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	PACKET3_INDEX_BUFFER_SIZE			0x13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	PACKET3_DISPATCH_DIRECT				0x15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	PACKET3_DISPATCH_INDIRECT			0x16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	PACKET3_ATOMIC_GDS				0x1D</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	PACKET3_ATOMIC_MEM				0x1E</span></span><br><span class="line">....</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	PACKET3_STRMOUT_BUFFER_UPDATE			0x34</span></span><br><span class="line">```</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACKET3(op, n)	((PACKET_TYPE3 &lt;&lt; 30) |				\</span></span><br><span class="line">			 (((op) &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>) |				\</span><br><span class="line">			 ((n) &amp; <span class="number">0x3FFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACKET3_COMPUTE(op, n) (PACKET3(op, n) | 1 &lt;&lt; 1)</span></span><br><span class="line">....</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Packet 3 types */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	PACKET3_NOP					0x10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	PACKET3_SET_BASE				0x11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>		PACKET3_BASE_INDEX(x)                  ((x) &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>			CE_PARTITION_BASE		3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	PACKET3_CLEAR_STATE				0x12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	PACKET3_INDEX_BUFFER_SIZE			0x13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	PACKET3_DISPATCH_DIRECT				0x15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	PACKET3_DISPATCH_INDIRECT			0x16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	PACKET3_ATOMIC_GDS				0x1D</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	PACKET3_ATOMIC_MEM				0x1E</span></span><br><span class="line">....</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	PACKET3_STRMOUT_BUFFER_UPDATE			0x34</span></span><br></pre></td></tr></table></figure>

<h3 id="PKT3-例子"><a href="#PKT3-例子" class="headerlink" title="PKT3 例子"></a>PKT3 例子</h3><p>Linux AMDGPU Driver在初始化完硬件后，会进行一个简单的Ring Test：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gfx_v10_0_ring_test_ring</span><span class="params">(struct amdgpu_ring *ring)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">amdgpu_device</span> *<span class="title">adev</span> =</span> ring-&gt;adev;</span><br><span class="line">	<span class="keyword">uint32_t</span> scratch;</span><br><span class="line">	<span class="keyword">uint32_t</span> tmp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> i;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	r = amdgpu_gfx_scratch_get(adev, &amp;scratch);											<span class="comment">/* 0 */</span></span><br><span class="line">	<span class="keyword">if</span> (r) &#123;</span><br><span class="line">		DRM_ERROR(<span class="string">&quot;amdgpu: cp failed to get scratch reg (%d).\n&quot;</span>, r);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	WREG32(scratch, <span class="number">0xCAFEDEAD</span>);														<span class="comment">/* 1 */</span></span><br><span class="line"></span><br><span class="line">	r = amdgpu_ring_alloc(ring, <span class="number">3</span>);														<span class="comment">/* 2 */</span></span><br><span class="line">	<span class="keyword">if</span> (r) &#123;</span><br><span class="line">		DRM_ERROR(<span class="string">&quot;amdgpu: cp failed to lock ring %d (%d).\n&quot;</span>,</span><br><span class="line">			  ring-&gt;idx, r);</span><br><span class="line">		amdgpu_gfx_scratch_free(adev, scratch);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	amdgpu_ring_write(ring, PACKET3(PACKET3_SET_UCONFIG_REG, <span class="number">1</span>));						<span class="comment">/* 3 */</span></span><br><span class="line">	amdgpu_ring_write(ring, (scratch - PACKET3_SET_UCONFIG_REG_START));</span><br><span class="line">	amdgpu_ring_write(ring, <span class="number">0xDEADBEEF</span>);</span><br><span class="line">	amdgpu_ring_commit(ring);															<span class="comment">/* 4 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; adev-&gt;usec_timeout; i++) &#123;</span><br><span class="line">		tmp = RREG32(scratch);															<span class="comment">/* 5 */</span></span><br><span class="line">		<span class="keyword">if</span> (tmp == <span class="number">0xDEADBEEF</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (amdgpu_emu_mode == <span class="number">1</span>)</span><br><span class="line">			msleep(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			udelay(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; adev-&gt;usec_timeout) &#123;</span><br><span class="line">		<span class="keyword">if</span> (amdgpu_emu_mode == <span class="number">1</span>)</span><br><span class="line">			DRM_INFO(<span class="string">&quot;ring test on %d succeeded in %d msecs\n&quot;</span>,</span><br><span class="line">				 ring-&gt;idx, i);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			DRM_INFO(<span class="string">&quot;ring test on %d succeeded in %d usecs\n&quot;</span>,</span><br><span class="line">				 ring-&gt;idx, i);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		DRM_ERROR(<span class="string">&quot;amdgpu: ring %d test failed (scratch(0x%04X)=0x%08X)\n&quot;</span>,</span><br><span class="line">			  ring-&gt;idx, scratch, tmp);</span><br><span class="line">		r = -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	amdgpu_gfx_scratch_free(adev, scratch);												<span class="comment">/* 6 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>命令解析：</strong></p>
<ol start="0">
<li><p>分配一个<code>scrathch</code>寄存器</p>
</li>
<li><p>使用CPU将其初始化为 0xCAFEDEAD</p>
</li>
<li><p>在Ring Buffer里分配一个 <code>3 + 1 </code> 长度空间</p>
</li>
<li><p>填写命令头</p>
<ul>
<li>PACKET3_SET_UCONFIG_REG： 命令类型，设置某一个寄存器的值</li>
<li>1： IT_BODY 长度为 1 + 1 </li>
<li>scratch - PACKET3_SET_UCONFIG_REG_START： 寄存器地址</li>
<li>0xDEADBEEF：寄存器值</li>
</ul>
</li>
<li><p>提交命令（更新wptr）到GPU</p>
</li>
<li><p>检查<code>scratch</code>寄存器的内容是否有变化：</p>
<ul>
<li>如果寄存器内容从 <code>0xCAFEDEAD</code>变化成 <code>0xDEADEEF</code>则表示命令执行成功，Ring工作正常</li>
</ul>
</li>
</ol>
<h1 id="AMD-GPU-Inidirect-Command-Buffer"><a href="#AMD-GPU-Inidirect-Command-Buffer" class="headerlink" title="AMD GPU Inidirect Command Buffer"></a>AMD GPU Inidirect Command Buffer</h1><p>Indirect Command Buffer又称为<strong>IB</strong>，是AMD GPU最常用的PKT3类型的命令包，主要功能就是间接的执行一组Command，只需要将Command所在的地址设置到命令包中即可，这种方式非常像编程里的函数调用，但是由于硬件限制，仅可以被调用一次，不可以嵌套执行。</p>
<h2 id="PKT3-INDIRECT-BUFFER"><a href="#PKT3-INDIRECT-BUFFER" class="headerlink" title="PKT3: INDIRECT BUFFER"></a>PKT3: INDIRECT BUFFER</h2><p><img src="/2020/10/25/amdgpu/AMD_GPU_Ring/pm4-indirect-buffer.png" alt="PM4 Indirect Buffer"></p>
<ul>
<li>HEADER: 包含命令类型，长度，OP等信息</li>
<li>IB_BASE_LO | IB_BASE_HI:  Command包在GPU视角下的地址</li>
<li>VMID： 因为命令包可以从不同VMID下发送下来，需要指定VMID才可以根据IB地址确定最终的物理地址</li>
<li>IB_SIZE： Command包的长度</li>
</ul>
<h2 id="PKT3-INDIRECT-BUFFER-例子"><a href="#PKT3-INDIRECT-BUFFER-例子" class="headerlink" title="PKT3: INDIRECT BUFFER 例子"></a>PKT3: INDIRECT BUFFER 例子</h2><p>AMD GPU KMD驱动在初始化结束的时候，同样会做一个简单的IB 测试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gfx_v10_0_ring_test_ib</span><span class="params">(struct amdgpu_ring *ring, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">amdgpu_device</span> *<span class="title">adev</span> =</span> ring-&gt;adev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">amdgpu_ib</span> <span class="title">ib</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dma_fence</span> *<span class="title">f</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span> scratch;</span><br><span class="line">	<span class="keyword">uint32_t</span> tmp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> r;</span><br><span class="line"></span><br><span class="line">	r = amdgpu_gfx_scratch_get(adev, &amp;scratch);											<span class="comment">/* 0 */</span></span><br><span class="line">	<span class="keyword">if</span> (r) &#123;</span><br><span class="line">		DRM_ERROR(<span class="string">&quot;amdgpu: failed to get scratch reg (%ld).\n&quot;</span>, r);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	WREG32(scratch, <span class="number">0xCAFEDEAD</span>);														<span class="comment">/* 1 */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;ib, <span class="number">0</span>, <span class="keyword">sizeof</span>(ib));</span><br><span class="line">	r = amdgpu_ib_get(adev, <span class="literal">NULL</span>, <span class="number">256</span>, &amp;ib);											<span class="comment">/* 2 */</span></span><br><span class="line">	<span class="keyword">if</span> (r) &#123;</span><br><span class="line">		DRM_ERROR(<span class="string">&quot;amdgpu: failed to get ib (%ld).\n&quot;</span>, r);</span><br><span class="line">		<span class="keyword">goto</span> err1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ib.ptr[<span class="number">0</span>] = PACKET3(PACKET3_SET_UCONFIG_REG, <span class="number">1</span>);									<span class="comment">/* 3 */</span></span><br><span class="line">	ib.ptr[<span class="number">1</span>] = ((scratch - PACKET3_SET_UCONFIG_REG_START));</span><br><span class="line">	ib.ptr[<span class="number">2</span>] = <span class="number">0xDEADBEEF</span>;</span><br><span class="line">	ib.length_dw = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	r = amdgpu_ib_schedule(ring, <span class="number">1</span>, &amp;ib, <span class="literal">NULL</span>, &amp;f);										<span class="comment">/* 4 */</span></span><br><span class="line">	<span class="keyword">if</span> (r)</span><br><span class="line">		<span class="keyword">goto</span> err2;</span><br><span class="line"></span><br><span class="line">	r = dma_fence_wait_timeout(f, <span class="literal">false</span>, timeout);										<span class="comment">/* 5 */</span></span><br><span class="line">	<span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">		DRM_ERROR(<span class="string">&quot;amdgpu: IB test timed out.\n&quot;</span>);</span><br><span class="line">		r = -ETIMEDOUT;</span><br><span class="line">		<span class="keyword">goto</span> err2;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		DRM_ERROR(<span class="string">&quot;amdgpu: fence wait failed (%ld).\n&quot;</span>, r);</span><br><span class="line">		<span class="keyword">goto</span> err2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tmp = RREG32(scratch);																<span class="comment">/* 6 */</span></span><br><span class="line">	<span class="keyword">if</span> (tmp == <span class="number">0xDEADBEEF</span>) &#123;</span><br><span class="line">		DRM_INFO(<span class="string">&quot;ib test on ring %d succeeded\n&quot;</span>, ring-&gt;idx);</span><br><span class="line">		r = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		DRM_ERROR(<span class="string">&quot;amdgpu: ib test failed (scratch(0x%04X)=0x%08X)\n&quot;</span>,</span><br><span class="line">			  scratch, tmp);</span><br><span class="line">		r = -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">err2:</span><br><span class="line">	amdgpu_ib_free(adev, &amp;ib, <span class="literal">NULL</span>);</span><br><span class="line">	dma_fence_put(f);</span><br><span class="line">err1:</span><br><span class="line">	amdgpu_gfx_scratch_free(adev, scratch);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<strong>IB</strong> 测试和之前的<strong>Ring Test</strong>一样，都是改写某一个寄存器：</p>
<ol start="0">
<li>分配一个<strong>scratch</strong>寄存器</li>
<li>CPU修改寄存器值为<strong>0xCAFEDEAD</strong></li>
<li>2为<strong>IB</strong>分配一块buffer</li>
<li>填充<strong>IB</strong>内容,内容为<code>PACKET3_SET_UCONFIG_REG</code>去设置寄存器</li>
<li>提交<strong>IB</strong>到GPU SHCEDULER，等待调度</li>
<li>等待<strong>IB</strong>执行完成</li>
<li>CPU检查<strong>scratch</strong>是否成功设置为<strong>0xdeadbeef</strong></li>
</ol>
<h1 id="AMD-GPU-HW-Queue-Type"><a href="#AMD-GPU-HW-Queue-Type" class="headerlink" title="AMD GPU HW Queue Type"></a>AMD GPU HW Queue Type</h1><ul>
<li>PQ (Primary Queue): 主要的AMD GPU Queue</li>
<li>IB(Indirect Buffer):  Indirect Buffer Queue</li>
<li>IQ(Interrupt Queue):  被挂起的Queue</li>
<li>EOP(End of Pipe): 用于标识Command执行完毕</li>
</ul>
<p>其中<strong>PQ</strong> 和 <strong>IB</strong> 是比较重要的2个Queue.</p>
<h1 id="AMD-GPU-Ring-Control"><a href="#AMD-GPU-Ring-Control" class="headerlink" title="AMD GPU Ring Control"></a>AMD GPU Ring Control</h1><p>Ring Buffer是软件和GPU硬件沟通的主要通道，其中<code>wptr</code>和<code>rptr</code>是两个非常重要的信息，那么软件和GPU是如何交互的呢？</p>
<p>KMD驱动会为每一个ring分配2个DWORD分别用于存取<code>rptr</code>和<code>wptr</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">r = amdgpu_device_wb_get(adev, &amp;ring-&gt;rptr_offs);</span><br><span class="line"><span class="keyword">if</span> (r) &#123;</span><br><span class="line">	dev_err(adev-&gt;dev, <span class="string">&quot;(%d) ring rptr_offs wb alloc failed\n&quot;</span>, r);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r = amdgpu_device_wb_get(adev, &amp;ring-&gt;wptr_offs);</span><br><span class="line"><span class="keyword">if</span> (r) &#123;</span><br><span class="line">	dev_err(adev-&gt;dev, <span class="string">&quot;(%d) ring wptr_offs wb alloc failed\n&quot;</span>, r);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r = amdgpu_device_wb_get(adev, &amp;ring-&gt;fence_offs);</span><br><span class="line"><span class="keyword">if</span> (r) &#123;</span><br><span class="line">	dev_err(adev-&gt;dev, <span class="string">&quot;(%d) ring fence_offs wb alloc failed\n&quot;</span>, r);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这2个DWORD所占用的内存 CPU 和 GPU 都可以直接访问，这样双方就可以通过共享内存的方式进行通信，但是GPU去轮寻<code>wptr</code>是否变化效率很低，因此GPU硬件还提供下面集中方式来更新<code>wptr</code>：</p>
<ul>
<li><p>操作寄存器 ：通过操作专用寄存器的方式来通知GPU硬件，寄存器有权限问题，不使用于User Mode Queue。</p>
</li>
<li><p>Doorbell：使用Doorbell机制来通知GPU硬件。 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Interrupt#Doorbell">doorbell</a></p>
</li>
<li><p>共享内存（硬件轮寻）： 让GPU去轮寻某一个地址上的值是否更新，效率低。</p>
</li>
</ul>
<h2 id="Doorbell"><a href="#Doorbell" class="headerlink" title="Doorbell"></a>Doorbell</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2f:00.0 VGA compatible controller [0300]: Advanced Micro Devices, Inc. [AMD/ATI] Navi 14 [Radeon RX 5500/5500M / Pro 5500M] [1002:7340] (rev c5) (prog-if 00 [VGA controller])</span><br><span class="line">        Subsystem: Advanced Micro Devices, Inc. [AMD/ATI] Navi 14 [Radeon RX 5500/5500M / Pro 5500M] [1002:0b0c]</span><br><span class="line">        Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx+</span><br><span class="line">        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-</span><br><span class="line">        Latency: 0, Cache Line Size: 64 bytes</span><br><span class="line">        Interrupt: pin A routed to IRQ 83</span><br><span class="line">        Region 0: Memory at d0000000 (64-bit, prefetchable) [size=256M]</span><br><span class="line">        Region 2: Memory at e0000000 (64-bit, prefetchable) [size=2M]</span><br><span class="line">        Region 4: I/O ports at f000 [size=256]</span><br><span class="line">        Region 5: Memory at fce00000 (32-bit, non-prefetchable) [size=512K]</span><br><span class="line">        Expansion ROM at fce80000 [disabled] [size=128K]</span><br><span class="line">        Capabilities: &lt;access denied&gt;</span><br><span class="line">        Kernel driver <span class="keyword">in</span> use: amdgpu</span><br></pre></td></tr></table></figure>

<ul>
<li>Region 2： GPU 硬件提供 2M 空间的Doorbell寄存器</li>
</ul>
<p>AMD GPU KMD驱动动态来的来管理这些Doorbell寄存器，这些寄存器可以动态的和某一个Ring进行关联，只需要将DoorBell 寄存器的Index信息设置到对应的寄存器中即可，软件就可以通过操作doorbell来达到更新wptr的目的。</p>
<blockquote>
<p>doorbell的分配要符合硬件限制。 </p>
</blockquote>
<h2 id="Example-GFX-更新WPTR"><a href="#Example-GFX-更新WPTR" class="headerlink" title="Example: GFX 更新WPTR"></a>Example: GFX 更新WPTR</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gfx_v10_0_ring_set_wptr_gfx</span><span class="params">(struct amdgpu_ring *ring)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">amdgpu_device</span> *<span class="title">adev</span> =</span> ring-&gt;adev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ring-&gt;use_doorbell) &#123;</span><br><span class="line">                <span class="comment">/* XXX check if swapping is necessary on BE */</span></span><br><span class="line">                atomic64_set((<span class="keyword">atomic64_t</span> *)&amp;adev-&gt;wb.wb[ring-&gt;wptr_offs], ring-&gt;wptr);</span><br><span class="line">                WDOORBELL64(ring-&gt;doorbell_index, ring-&gt;wptr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                WREG32_SOC15(GC, <span class="number">0</span>, mmCP_RB0_WPTR, lower_32_bits(ring-&gt;wptr));</span><br><span class="line">                WREG32_SOC15(GC, <span class="number">0</span>, mmCP_RB0_WPTR_HI, upper_32_bits(ring-&gt;wptr));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果ring支持doorbell操作，就使用分配好的doorbell来更新wptr值</li>
<li>如果ring不支持doorbell，就使用更新寄存器的方式来更新wptr</li>
</ul>
<h1 id="AMD-GPU-Ring-HW-Fence"><a href="#AMD-GPU-Ring-HW-Fence" class="headerlink" title="AMD GPU Ring HW Fence"></a>AMD GPU Ring HW Fence</h1><p>AMD GPU KMD在初始化ring的时候除了分配<code>wptr</code> 和 <code>rptr</code>还会分配一个<code>fence</code>的DWORD，用于接受GPU传递的信息。<br>当CPU发送命令给GPU后，CPU有时候需要知道命令是否执行完毕，因此在必要的时候，CPU会在发送命令的时候在发送一个额外的packet命令包，这个命令包会在某一个地址上写入一个软件标记，并产生一个硬件中断来通知软件命令已经执行完毕。</p>
<h2 id="Fence-Emit"><a href="#Fence-Emit" class="headerlink" title="Fence Emit"></a>Fence Emit</h2><ul>
<li>PACKET3_RELEASE_MEM： 用于产生一个EOP事件，标识硬件已经执行完一组命令，可以释放一些硬件资源，并将一个软件标记写入到指定内存地址，并产生一个硬件中断来通知软件。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gfx_v10_0_ring_emit_fence</span><span class="params">(struct amdgpu_ring *ring, u64 addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     u64 seq, <span class="keyword">unsigned</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">amdgpu_device</span> *<span class="title">adev</span> =</span> ring-&gt;adev;</span><br><span class="line">        <span class="keyword">bool</span> write64bit = flags &amp; AMDGPU_FENCE_FLAG_64BIT;</span><br><span class="line">        <span class="keyword">bool</span> int_sel = flags &amp; AMDGPU_FENCE_FLAG_INT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Interrupt not work fine on GFX10.1 model yet. Use fallback instead */</span></span><br><span class="line">        <span class="keyword">if</span> (adev-&gt;pdev-&gt;device == <span class="number">0x50</span>)</span><br><span class="line">                int_sel = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* RELEASE_MEM - flush caches, send int */</span></span><br><span class="line">        amdgpu_ring_write(ring, PACKET3(PACKET3_RELEASE_MEM, <span class="number">6</span>));										<span class="comment">/* 0 */</span></span><br><span class="line">        amdgpu_ring_write(ring, (PACKET3_RELEASE_MEM_GCR_SEQ |</span><br><span class="line">                                 PACKET3_RELEASE_MEM_GCR_GL2_WB |</span><br><span class="line">                                 PACKET3_RELEASE_MEM_GCR_GLM_INV | <span class="comment">/* must be set with GLM_WB */</span></span><br><span class="line">                                 PACKET3_RELEASE_MEM_GCR_GLM_WB |</span><br><span class="line">                                 PACKET3_RELEASE_MEM_CACHE_POLICY(<span class="number">3</span>) |</span><br><span class="line">                                 PACKET3_RELEASE_MEM_EVENT_TYPE(CACHE_FLUSH_AND_INV_TS_EVENT) |</span><br><span class="line">                                 PACKET3_RELEASE_MEM_EVENT_INDEX(<span class="number">5</span>)));</span><br><span class="line">        amdgpu_ring_write(ring, (PACKET3_RELEASE_MEM_DATA_SEL(write64bit ? <span class="number">2</span> : <span class="number">1</span>) |</span><br><span class="line">                                 PACKET3_RELEASE_MEM_INT_SEL(int_sel ? <span class="number">2</span> : <span class="number">0</span>)));						<span class="comment">/* 1 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * the address should be Qword aligned if 64bit write, Dword</span></span><br><span class="line"><span class="comment">         * aligned if only send 32bit data low (discard data high)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (write64bit)</span><br><span class="line">                BUG_ON(addr &amp; <span class="number">0x7</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                BUG_ON(addr &amp; <span class="number">0x3</span>);</span><br><span class="line">        amdgpu_ring_write(ring, lower_32_bits(addr));													<span class="comment">/* 2 */</span></span><br><span class="line">        amdgpu_ring_write(ring, upper_32_bits(addr));</span><br><span class="line">        amdgpu_ring_write(ring, lower_32_bits(seq));													<span class="comment">/* 3 */</span></span><br><span class="line">        amdgpu_ring_write(ring, upper_32_bits(seq));</span><br><span class="line">        amdgpu_ring_write(ring, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="0">
<li>初始化 <code>PACKET3_RELEASE_MEM</code> header</li>
<li>设置是否要产生硬件中断</li>
<li>设置标记地址</li>
<li>设置标记内容</li>
</ol>
<p>因为在GPU硬件中，PKT3一般都是顺序执行的，这条PKT执行完毕后，会产生一个硬件终端，并标这条PKT之前的命令都已经执行完毕。</p>
<blockquote>
<p>seq是软件维护的一个单调递增的数字标记，用于表示pkt执行的位置。（Per-Ring）</p>
</blockquote>
<p>当硬件执行收到中断后，会在中断处理函数中释放<code>fence</code>，并按照<code>dma-fence</code>接口通知关心这个事件的人。</p>
<h2 id="Fence-Process"><a href="#Fence-Process" class="headerlink" title="Fence Process"></a>Fence Process</h2><p>当GPU收到硬件的中断后，会根据中断所提供的信息，路由到具体<code>ring</code>中，并执行<code>amdgpu_fence_process()</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">amdgpu_fence_process</span><span class="params">(struct amdgpu_ring *ring)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">amdgpu_fence_driver</span> *<span class="title">drv</span> =</span> &amp;ring-&gt;fence_drv;</span><br><span class="line">        <span class="keyword">uint32_t</span> seq, last_seq;</span><br><span class="line">        <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                last_seq = atomic_read(&amp;ring-&gt;fence_drv.last_seq);</span><br><span class="line">                seq = amdgpu_fence_read(ring);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (atomic_cmpxchg(&amp;drv-&gt;last_seq, last_seq, seq) != last_seq);		<span class="comment">/* 0 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (del_timer(&amp;ring-&gt;fence_drv.fallback_timer) &amp;&amp;</span><br><span class="line">            seq != ring-&gt;fence_drv.sync_seq)</span><br><span class="line">                amdgpu_fence_schedule_fallback(ring);								<span class="comment">/* 1 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(seq == last_seq))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        last_seq &amp;= drv-&gt;num_fences_mask;</span><br><span class="line">        seq &amp;= drv-&gt;num_fences_mask;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">dma_fence</span> *<span class="title">fence</span>, **<span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">                ++last_seq;</span><br><span class="line">                last_seq &amp;= drv-&gt;num_fences_mask;</span><br><span class="line">                ptr = &amp;drv-&gt;fences[last_seq];</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* There is always exactly one thread signaling this fence slot */</span></span><br><span class="line">                fence = rcu_dereference_protected(*ptr, <span class="number">1</span>);</span><br><span class="line">                RCU_INIT_POINTER(*ptr, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!fence)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                r = dma_fence_signal(fence);										<span class="comment">/* 2 */</span></span><br><span class="line">                <span class="keyword">if</span> (!r)</span><br><span class="line">                        DMA_FENCE_TRACE(fence, <span class="string">&quot;signaled from irq context\n&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        BUG();</span><br><span class="line"></span><br><span class="line">                dma_fence_put(fence);</span><br><span class="line">        &#125; <span class="keyword">while</span> (last_seq != seq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="0">
<li>因为IRQ的负载均衡的原因，中断可能被分配到不同的cpu上，这里采用类似读写锁的方式来保证各个cpu上处理的fence不会冲突</li>
<li>因为fence在发射的时候还会额外启动一个定时器，当定时器超时后，会强制处理fence，这里重新调整定时器延迟</li>
<li>使用<code>dma_fence</code>提供的signal接口，依次调用cb函数，来通知关心这个fence的人。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文简单的介绍了一下KMD下实现的Ring Buffer，希望能对你有所帮助。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>AMD GPU Ring Buffer</p><p><a href="https://xxlnx.github.io/2020/10/25/amdgpu/AMD_GPU_Ring/">https://xxlnx.github.io/2020/10/25/amdgpu/AMD_GPU_Ring/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Wang Yang</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-10-25</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2020-10-25</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/kernel/">kernel</a><a class="link-muted mr-2" rel="tag" href="/tags/amdgpu/">amdgpu</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/10/25/amdgpu/AMD_GPU_VMID_HW/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">AMD GPU VMID</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/07/05/amdgpu/AMD_GPU_Virtual_Memory/"><span class="level-item">AMD GPU 虚拟内存</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Wang Yang"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Wang Yang</p><p class="is-size-6 is-block">Software Engineer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shang Hai</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">8</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/xxlnx" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#背景"><span class="level-left"><span class="level-item">1</span><span class="level-item">背景</span></span></a></li><li><a class="level is-mobile" href="#AMD-GPU-Ring-Buffer"><span class="level-left"><span class="level-item">2</span><span class="level-item">AMD GPU Ring Buffer</span></span></a></li><li><a class="level is-mobile" href="#AMD-GPU-Ring-命令类型"><span class="level-left"><span class="level-item">3</span><span class="level-item">AMD GPU Ring 命令类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#PM4-Packet-0"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">PM4: Packet 0</span></span></a></li><li><a class="level is-mobile" href="#PM4-Packet-1"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">PM4: Packet 1</span></span></a></li><li><a class="level is-mobile" href="#PM4-Packet-2"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">PM4: Packet 2</span></span></a></li><li><a class="level is-mobile" href="#PM4-Packet-3"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">PM4: Packet 3</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#PKT3-IT-OPCODE-列表"><span class="level-left"><span class="level-item">3.4.1</span><span class="level-item">PKT3 IT_OPCODE 列表</span></span></a></li><li><a class="level is-mobile" href="#PKT3-例子"><span class="level-left"><span class="level-item">3.4.2</span><span class="level-item">PKT3 例子</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#AMD-GPU-Inidirect-Command-Buffer"><span class="level-left"><span class="level-item">4</span><span class="level-item">AMD GPU Inidirect Command Buffer</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#PKT3-INDIRECT-BUFFER"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">PKT3: INDIRECT BUFFER</span></span></a></li><li><a class="level is-mobile" href="#PKT3-INDIRECT-BUFFER-例子"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">PKT3: INDIRECT BUFFER 例子</span></span></a></li></ul></li><li><a class="level is-mobile" href="#AMD-GPU-HW-Queue-Type"><span class="level-left"><span class="level-item">5</span><span class="level-item">AMD GPU HW Queue Type</span></span></a></li><li><a class="level is-mobile" href="#AMD-GPU-Ring-Control"><span class="level-left"><span class="level-item">6</span><span class="level-item">AMD GPU Ring Control</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Doorbell"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">Doorbell</span></span></a></li><li><a class="level is-mobile" href="#Example-GFX-更新WPTR"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">Example: GFX 更新WPTR</span></span></a></li></ul></li><li><a class="level is-mobile" href="#AMD-GPU-Ring-HW-Fence"><span class="level-left"><span class="level-item">7</span><span class="level-item">AMD GPU Ring HW Fence</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Fence-Emit"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">Fence Emit</span></span></a></li><li><a class="level is-mobile" href="#Fence-Process"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">Fence Process</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">8</span><span class="level-item">总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/amdgpu/"><span class="level-start"><span class="level-item">amdgpu</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/gpu/"><span class="level-start"><span class="level-item">gpu</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/gpu/scheduler/"><span class="level-start"><span class="level-item">scheduler</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/iommu/"><span class="level-start"><span class="level-item">iommu</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/tool/"><span class="level-start"><span class="level-item">tool</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/amd64/"><span class="tag">amd64</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/amdgpu/"><span class="tag">amdgpu</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gpu/"><span class="tag">gpu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iommu/"><span class="tag">iommu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kernel/"><span class="tag">kernel</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/scheduler/"><span class="tag">scheduler</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tool/"><span class="tag">tool</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/virtualization/"><span class="tag">virtualization</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.png" alt="Wang Yang&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Wang Yang</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };

</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><script src="/js/main.js" defer></script><script>var mermaidSettings = {
                theme: 'forest'
            };
</script><script src="https://unpkg.com/mermaid@8.9.2/dist/mermaid.min.js" defer>mermaid.initialize(mermaidSettings)</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>